{"version":3,"sources":["blacklist.js","board.js","segment.js","symbols.js","word.js","placement.js","state.js","solve.js","tray.js","assets/words.txt","trie.js","solver.js","index.js"],"names":["Blacklist","blacklistStr","this","words","Set","split","word","has","createBlacklist","Board","numCols","numRows","rows","Map","Array","keys","map","rowIndex","row","board","get","columns","fill","forEach","col","colIndex","placement","placementDelta","getDelta","newRow","newCol","rowsToAdd","colsToAdd","rowCols","rowKey","cols","colKey","set","down","wordArr","letter","index","newRowPlusIndex","tileRow","colPlusIndex","Math","max","Segment","BRANCHES_KEY","Symbol","FINISHES_WORD","PARENT_BRANCH","Word","solve","branch","parts","segment","state","getSolve","getState","blacklist","getBlacklist","tray","getTray","trie","getSolver","getTrie","length","result","getNextValidWord","loop","some","childBranch","part","partMeetsCriteria","push","inception","lastPart","pop","join","allows","slice","getData","counts","getCountsWith","instances","replaceAll","createWord","init","Placement","getArray","total","createPlacement","getNext","tiles","newPlacement","State","parent","getPlacedTiles","getPlacement","previous","isEmpty","Solve","solver","update","message","boardArr","getBoard","remainingTray","getString","start","config","Date","getTime","step","createState","isSolved","handleUpdate","tryNextStep","getAdvanced","prevState","getPrev","maybeNextState","nextStepTimeout","setTimeout","clearTimeout","Tray","str","reduce","count","getCounts","tilesToRemove","newTrayStr","tileToRemove","replace","codes","c","n","decode","code","codeLength","num","places","pow","range","i","d","charCodeAt","Trie","data","Promise","resolve","fetch","wordsTxt","then","response","a","pattern","RegExp","syms","text","nodes","node","symParts","exec","size","processNode","parentBranch","branches","matches","ref","undefined","Solver","solveStart","updateFn","ready","trayStr","App","useState","setBlacklistStr","setBoardArr","setMessage","setReady","setRemainingTray","setTrayStr","setters","onUpdate","Object","key","toUpperCase","className","type","placeholder","value","onInput","event","target","toLowerCase","disabled","newBlacklistStr","cell","cellIndex","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.bb7b5b86.chunk.js","sourcesContent":["class Blacklist {\n  constructor(blacklistStr) {\n    this.words = new Set(blacklistStr.split(/\\s*,\\s*/));\n  }\n  allows(word) {\n    return !this.words.has(word);\n  }\n}\n\nexport const createBlacklist = (blacklistStr) => new Blacklist(blacklistStr);\n","class Board {\n  constructor({ numCols, numRows, rows }) {\n    this.numCols = numCols || 1;\n    this.numRows = numRows || 1;\n    this.rows = rows || new Map([[0, new Map([[0, \" \"]])]]);\n  }\n  getArray() {\n    return [...Array(this.numRows).keys()].map((rowIndex) => {\n      const row = this.board.get(rowIndex);\n      const columns = Array(this.numCols).fill(\" \");\n      if (row) {\n        row.forEach((col, colIndex) => {\n          columns[colIndex] = col;\n        });\n      }\n      return columns;\n    });\n  }\n  getNext(placement) {\n    const placementDelta = placement.getDelta();\n    const rows = new Map();\n    let newRow = placementDelta.row;\n    let newCol = placementDelta.col;\n    let numCols = this.numCols;\n    let rowsToAdd = 0;\n    let colsToAdd = 0;\n    if (newRow < 0) {\n      rowsToAdd = -newRow;\n      newRow = 0;\n    }\n    if (newCol < 0) {\n      colsToAdd = -newCol;\n      newCol = 0;\n    }\n    this.rows.forEach((rowCols, rowKey) => {\n      const cols = new Map();\n      rowCols.forEach((col, colKey) => {\n        if (colsToAdd + colKey + 1 > numCols) {\n          numCols = colsToAdd + colKey + 1;\n        }\n        cols.set(colsToAdd + colKey, col);\n      });\n      rows.set(rowsToAdd + rowKey, cols);\n    });\n    if (placementDelta.down) {\n      placementDelta.wordArr.forEach((letter, index) => {\n        const newRowPlusIndex = newRow + index;\n        if (!rows.has(newRowPlusIndex)) {\n          rows.set(newRowPlusIndex, new Map());\n        }\n        const tileRow = rows.get(newRowPlusIndex);\n        tileRow.set(newCol, letter);\n      });\n    } else {\n      const tileRow = rows.get(newRow);\n      placementDelta.wordArr.split(\"\").forEach((letter, index) => {\n        const colPlusIndex = newCol + index;\n        tileRow.set(colPlusIndex, letter);\n      });\n    }\n    const numRows = Math.max(...rows.keys()) + 1;\n    return new Board({ numCols, numRows, rows });\n  }\n}\n\nexport const createBoard = (config) => new Board(config);\n","class Segment {\n  constructor({ board }) {\n    this.board = board;\n  }\n  getNext() {\n    // TODO\n  }\n}\n\nexport const createSegment = (config) => new Segment(config);\n","export const BRANCHES_KEY = Symbol(\"Branches\");\nexport const FINISHES_WORD = Symbol(\"Finishes Word\");\nexport const PARENT_BRANCH = Symbol(\"Parent Branch\");\n","import { BRANCHES_KEY, FINISHES_WORD, PARENT_BRANCH } from \"./symbols\";\n\nclass Word {\n  constructor({ branch, parts, placement, segment, state, word }) {\n    let solve;\n    if (state) {\n      solve = state.getSolve();\n    } else {\n      state = placement.getState();\n      solve = state.getSolve();\n    }\n    this.blacklist = solve.getBlacklist();\n    this.branch = branch;\n    this.parts = parts;\n    this.segment = segment;\n    this.tray = state.getTray();\n    this.trie = solve.getSolver().getTrie();\n    this.word = word;\n    this.wordArr = word ? word.split(\"\") : [];\n  }\n  getArray() {\n    if (!this.wordArr.length) {\n      this.wordArr = this.word.split(\"\");\n    }\n    return this.wordArr;\n  }\n  getNext() {\n    const result = this.getNextValidWord();\n    if (!result) {\n      return false;\n    }\n    return new Word({\n      branch: result.branch,\n      parts: result.parts,\n      placement: this.placement,\n      segment: this.segment,\n      state: this.state,\n      word: result.word,\n    });\n  }\n  getNextValidWord() {\n    const loop = (parts, branch) => {\n      const inception = (branch, parts) => {\n        let lastPart = parts.pop();\n        if (\n          !branch.get(BRANCHES_KEY).some((childBranch, part) => {\n            if (lastPart) {\n              if (lastPart === part) {\n                lastPart = false;\n              }\n              return false;\n            }\n            if (this.partMeetsCriteria(part)) {\n              parts.push(part);\n              branch = childBranch;\n              return true;\n            }\n            return false;\n          })\n        ) {\n          if (branch.has(PARENT_BRANCH)) {\n            return inception(branch.get(PARENT_BRANCH), parts);\n          } else {\n            return false;\n          }\n        }\n        return { branch, parts };\n      };\n      if (branch.has(BRANCHES_KEY)) {\n        branch.get(BRANCHES_KEY).some((childBranch, part) => {\n          if (this.partMeetsCriteria(part)) {\n            parts.push(part);\n            branch = childBranch;\n            return true;\n          }\n          return false;\n        });\n      } else if (branch.has(PARENT_BRANCH)) {\n        const result = inception(branch.get(PARENT_BRANCH), parts);\n        if (!result) {\n          return false;\n        }\n        branch = result.branch;\n        parts = result.parts;\n      } else {\n        return false;\n      }\n      const word = parts.join(\"\");\n      if (branch.has(FINISHES_WORD) && this.blacklist.allows(word) && this.segment.allows(word)) {\n        return new Word({ branch, parts, placement: this, segment: this.segment, word });\n      } else {\n        return loop(parts.slice(), branch);\n      }\n    };\n    return loop(this.parts.slice() || [\"a\"], this.branch || this.trie.getData().get(\"a\"));\n  }\n  init() {\n    const result = this.getNextValidWord();\n    if (!result) {\n      return false;\n    }\n    this.branch = result.branch;\n    this.parts = result.parts;\n    this.word = result.word;\n    this.wordArr = result.word.split(\"\");\n  }\n  partMeetsCriteria(part) {\n    const counts = this.tray.getCountsWith(this.segment);\n    while (part.length > 0) {\n      const letter = part[0];\n      let instances = 0;\n      part = part.replaceAll(letter, () => {\n        instances++;\n        return \"\";\n      });\n      if (!counts.has(letter) || counts.get(letter) < instances) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nexport const createWord = ({ placement, segment, state }) => {\n  const word = new Word({ placement, segment, state });\n  if (!word.init()) {\n    return false;\n  }\n  return word;\n};\n","import { createSegment } from \"./segment\";\nimport { createWord } from \"./word\";\n\nclass Placement {\n  constructor({ index, placement, segment, state, word }) {\n    this.index = index;\n    this.placement = placement;\n    this.segment = segment;\n    this.state = state;\n    this.word = word;\n  }\n  init() {\n    // TODO: calculate row, col, down, tiles, total\n    // TODO: return false if a placement can't be made\n  }\n  getDelta() {\n    const { col, down, row, word } = this;\n    const wordArr = word.getArray();\n    return { col, down, row, wordArr };\n  }\n  getNext() {\n    const index = this.index ? this.index + 1 : 1;\n    if (index < this.total) {\n      return createPlacement({ index, placement: this });\n    }\n    let word = this.word.getNext();\n    if (word) {\n      return createPlacement({ placement: this, word });\n    }\n    let segment = this.segment.getNext();\n    if (!segment) {\n      return false;\n    }\n    word = createWord({ placement: this, segment });\n    while (!word) {\n      segment = segment.getNext();\n      if (segment) {\n        word = createWord({ placement: this, segment });\n      } else {\n        return false;\n      }\n    }\n    return createPlacement({ placement: this, segment, word });\n  }\n  getPlacedTiles() {\n    return this.tiles;\n  }\n  getState() {\n    return this.state;\n  }\n}\n\nexport const createPlacement = ({ index, placement, segment, state, word }) => {\n  segment = segment || createSegment({ state });\n  if (!segment) {\n    return false;\n  }\n  word = word || createWord({ segment, state });\n  if (!word) {\n    return false;\n  }\n  const newPlacement = new Placement({ index, placement, segment, state, word });\n  if (!newPlacement.init()) {\n    return false;\n  }\n  return newPlacement;\n};\n","import { createPlacement } from \"./placement\";\n\nclass State {\n  constructor({ board, parent, placement, solve, tray }) {\n    this.board = board;\n    this.parent = parent;\n    this.placement = placement;\n    this.solve = solve;\n    this.tray = tray || solve.getTray();\n  }\n  getAdvanced() {\n    const placement = createPlacement({ state: this });\n    if (!placement) {\n      return false;\n    }\n    return new State({\n      board: this.board.getNext(placement),\n      parent: this,\n      placement,\n      tray: this.tray.getNext(placement.getPlacedTiles()),\n    });\n  }\n  getBoard() {\n    return this.board;\n  }\n  getNext() {\n    const parent = this.parent;\n    const placement = parent.getPlacement().getNext();\n    if (!placement) {\n      return false;\n    }\n    const board = this.board.getNext(placement);\n    if (!board) {\n      return false;\n    }\n    return new State({\n      blacklist: this.blacklist,\n      board,\n      parent,\n      placement,\n      tray: this.tray.getNext(placement.getPlacedTiles()),\n    });\n  }\n  getPlacement() {\n    return this.placement;\n  }\n  getPrev() {\n    return this.previous;\n  }\n  getSolve() {\n    return this.solve;\n  }\n  getTray() {\n    return this.tray;\n  }\n  isSolved() {\n    return this.tray.isEmpty();\n  }\n}\n\nexport const createState = (config) => new State(config);\n","import { createBoard } from \"./board\";\nimport { createState } from \"./state\";\n\nclass Solve {\n  constructor({ blacklist, solver, tray, update }) {\n    this.blacklist = blacklist;\n    this.solver = solver;\n    this.tray = tray;\n    this.update = update;\n  }\n  getBlacklist() {\n    return this.blacklist;\n  }\n  getSolver() {\n    return this.solver;\n  }\n  getTray() {\n    return this.tray;\n  }\n  handleUpdate(state, message) {\n    const boardArr = state.getBoard().getArray();\n    const remainingTray = state.getTray().getString();\n    return this.update({ boardArr, message, remainingTray }, this.start);\n  }\n  start() {\n    this.start = new Date().getTime();\n    this.step(\n      createState({\n        board: createBoard({}),\n        solve: this,\n      })\n    );\n    return this.start;\n  }\n  step(state) {\n    if (state.isSolved()) {\n      this.handleUpdate(state, \"Solution found!\");\n      return;\n    }\n    if (!this.tryNextStep(state.getAdvanced(), \"Advancing state...\")) {\n      if (!this.tryNextStep(state.getNext(), \"Trying next state...\")) {\n        let prevState = state.getPrev();\n        while (prevState) {\n          if (this.tryNextStep(prevState.getNext(), \"Trying previous next state...\")) {\n            return;\n          }\n          prevState = prevState.getPrev();\n        }\n        this.handleUpdate(state, \"No solutions possible!\");\n      }\n    }\n  }\n  tryNextStep(maybeNextState, message) {\n    if (!maybeNextState) {\n      return false;\n    }\n    const nextStepTimeout = setTimeout(() => this.step(maybeNextState));\n    if (!this.handleUpdate(maybeNextState, message)) {\n      clearTimeout(nextStepTimeout);\n    }\n    return true;\n  }\n}\n\nexport const createSolve = (config) => {\n  const solve = new Solve(config);\n  return solve.start();\n};\n","class Tray {\n  constructor(str) {\n    this.str = str;\n    this.counts = str.split(\"\").reduce((counts, letter) => {\n      counts.set(letter, counts.has(letter) ? counts.get(letter) + 1 : 1);\n      return counts;\n    }, new Map());\n  }\n  getCountsWith(segment) {\n    const counts = new Map();\n    this.counts.forEach((count, letter) => {\n      counts[letter] = count;\n    });\n    segment.getCounts().forEach((count, letter) => {\n      counts.set(letter, this.counts.has(letter) ? this.counts.get(letter) + count : count);\n    });\n    return counts;\n  }\n  getNext(tilesToRemove) {\n    let newTrayStr = this.str;\n    tilesToRemove.forEach((tileToRemove) => {\n      newTrayStr = newTrayStr.replace(tileToRemove, \"\");\n    });\n    return new Tray(newTrayStr);\n  }\n  getString() {\n    return this.str;\n  }\n  isEmpty() {\n    return !this.str;\n  }\n}\n\nexport const createTray = (str) => new Tray(str);\n","export default __webpack_public_path__ + \"static/media/words.cc212d38.txt\";","import { BRANCHES_KEY, FINISHES_WORD, PARENT_BRANCH } from \"./symbols\";\nimport wordsTxt from \"./assets/words.txt\";\n\nconst codes = new Map(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\").map((c, n) => [c, n]));\n\nconst decode = (code) => {\n  if (codes.has(code)) {\n    return codes.get(code);\n  }\n  const base = 36;\n  const codeLength = code.length;\n  let num = 0;\n  let places = 1;\n  let pow = 1;\n  let range = base;\n  while (places < codeLength) {\n    num += range;\n    places++;\n    range *= base;\n  }\n  for (let i = codeLength - 1; i >= 0; i--) {\n    let d = code.charCodeAt(i) - 48;\n    if (d > 10) {\n      d -= 7;\n    }\n    num += d * pow;\n    pow *= base;\n  }\n  codes.set(code, num);\n  return num;\n};\n\nclass Trie {\n  getData() {\n    return this.data;\n  }\n  init() {\n    return new Promise((resolve) => {\n      fetch(wordsTxt.slice(1)).then(async (response) => {\n        const pattern = new RegExp(\"([0-9A-Z]+):([0-9A-Z]+)\");\n        const syms = new Map();\n        let nodes = (await response.text()).split(\";\");\n        nodes.some((node) => {\n          const symParts = pattern.exec(node);\n          if (!symParts) {\n            return true;\n          }\n          syms.set(symParts[1], decode(symParts[2]));\n          return false;\n        });\n        nodes = nodes.slice(syms.size);\n        const processNode = (index, parentBranch) => {\n          let node = nodes[index];\n          const branch = new Map();\n          const branches = new Map();\n          branch.set(BRANCHES_KEY, branches);\n          if (parentBranch) {\n            branch.set(PARENT_BRANCH, parentBranch);\n          }\n          if (node[0] === \"!\") {\n            branch.set(FINISHES_WORD, true);\n            node = node.slice(1);\n          }\n          const matches = node.split(/([A-Z0-9,]+)/g);\n          let i = 0;\n          while (i < matches.length) {\n            const part = matches[i];\n            if (!part) {\n              i += 2;\n              continue;\n            }\n            const ref = matches[i + 1];\n            if (ref === \",\" || ref === undefined) {\n              branches.set(part, new Map([[FINISHES_WORD, true]]));\n              i += 2;\n              continue;\n            }\n            branches.set(part, processNode(syms.has(ref) ? syms.get(ref) : index + decode(ref) + 1 - syms.size, branch));\n            i += 2;\n          }\n          return branch;\n        };\n        this.data = processNode(0);\n        resolve();\n      });\n    });\n  }\n}\n\nexport const createTrie = () => new Trie();\n","import { createBlacklist } from \"./blacklist\";\nimport { createSolve } from \"./solve\";\nimport { createTray } from \"./tray\";\nimport { createTrie } from \"./trie\";\n\nclass Solver {\n  constructor() {\n    this.solveStart = 0;\n    this.trie = createTrie();\n    this.trie.init().then(() => {\n      this.updateFn({ ready: true });\n    });\n  }\n  getTrie() {\n    return this.trie;\n  }\n  onUpdate(updateFn) {\n    this.updateFn = updateFn;\n  }\n  solve({ blacklistStr, trayStr }) {\n    this.solveStart = createSolve({\n      blacklist: createBlacklist(blacklistStr),\n      solver: this,\n      tray: createTray(trayStr),\n      update: (update, start) => {\n        if (start !== this.solveStart) {\n          return false;\n        }\n        this.updateFn(update);\n        return true;\n      },\n    });\n  }\n}\n\nexport const createSolver = () => new Solver();\n","import \"./assets/styles.css\";\nimport { createSolver } from \"./solver\";\nimport React, { useState } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nconst solver = createSolver();\n\nconst App = () => {\n  const [blacklistStr, setBlacklistStr] = useState(\"\");\n  const [boardArr, setBoardArr] = useState([[\" \"]]);\n  const [message, setMessage] = useState(\"Loading...\");\n  const [ready, setReady] = useState(false);\n  const [remainingTray, setRemainingTray] = useState(\"\");\n  const [trayStr, setTrayStr] = useState(\"\");\n  const setters = { setBoardArr, setMessage, setReady, setRemainingTray };\n  const updateBlacklistStr = (event) => {\n    const newBlacklistStr = event.target.value.replace(/[^A-Z,]/gi, \"\").toLowerCase();\n    setBlacklistStr(newBlacklistStr);\n    solver.solve({ blacklistStr: newBlacklistStr, trayStr });\n  };\n  const updateTrayStr = (event) => {\n    const newTrayStr = event.target.value.replace(/[^A-Z]/gi, \"\").toLowerCase();\n    setTrayStr(newTrayStr);\n    solver.solve({ blacklistStr, trayStr: newTrayStr });\n  };\n  solver.onUpdate((update) => Object.keys(update).forEach((key) => setters[`set${key.slice(0, 1).toUpperCase()}${key.slice(1)}`](update[key])));\n  return (\n    <div>\n      <div className=\"header\">\n        <h1>Bananagrams Helper</h1>\n      </div>\n      <div className=\"letterbox\">\n        <input type=\"text\" placeholder=\"yourtileshere\" value={trayStr} onInput={updateTrayStr} disabled={!ready} />\n      </div>\n      <div className=\"controls\">\n        <div>\n          <label>Word Blacklist</label>\n          <small>(Comma-separated)</small>\n        </div>\n        <div>\n          <input type=\"text\" value={blacklistStr} onInput={updateBlacklistStr} disabled={!ready} />\n        </div>\n      </div>\n      <div className=\"boardbox\">\n        <div className=\"board\">\n          {boardArr.map((row, rowIndex) => (\n            <div key={rowIndex} className=\"row\">\n              {row.map((cell, cellIndex) => (\n                <div key={cellIndex} className={cell === \" \" ? \"cell empty\" : \"cell\"}>\n                  {cell}\n                </div>\n              ))}\n            </div>\n          ))}\n        </div>\n      </div>\n      <div className=\"tray\">{remainingTray}</div>\n      <div className=\"message\">{message}</div>\n    </div>\n  );\n};\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"app\")\n);\n"],"sourceRoot":""}